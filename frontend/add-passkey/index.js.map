{
  "version": 3,
  "sources": ["file:///C:/Users/trent/Files/Projects/identity-service/frontend/lib/form.ts", "file:///C:/Users/trent/Files/Projects/identity-service/frontend/lib/redirect.ts", "file:///C:/Users/trent/Files/Projects/identity-service/frontend/lib/base64.ts", "file:///C:/Users/trent/Files/Projects/identity-service/frontend/lib/fetch.ts", "file:///C:/Users/trent/Files/Projects/identity-service/frontend/scripts/config.ts", "file:///C:/Users/trent/Files/Projects/identity-service/frontend/scripts/token.ts", "file:///C:/Users/trent/Files/Projects/identity-service/frontend/scripts/webauthn.ts", "file:///C:/Users/trent/Files/Projects/identity-service/frontend/add-passkey/index.ts"],
  "sourcesContent": ["import { Problem } from \"./fetch.ts\";\r\n\r\nexport class FormError {\r\n  element: HTMLElement;\r\n  contents: HTMLElement;\r\n  action: string;\r\n\r\n  constructor(formId: string, action: string) {\r\n    this.element = getElementById<HTMLElement>(`${formId}/error`, HTMLElement);\r\n    this.contents = getElementById<HTMLElement>(`${formId}/error/content`, HTMLElement);\r\n    this.action = action;\r\n  }\r\n\r\n  clearError() {\r\n    this.element.classList.add(\"collapse\");\r\n    this.element.ariaHidden = \"true\";\r\n    this.contents.textContent = \"\";\r\n  }\r\n\r\n  addError(error: string) {\r\n    if (this.contents.textContent === \"\") {\r\n      this.element.classList.remove(\"collapse\");\r\n      this.element.ariaHidden = \"false\";\r\n      this.contents.textContent = `Could not ${this.action}: ${error}`;\r\n      return;\r\n    }\r\n\r\n    this.contents.textContent += `, ${error}`;\r\n  }\r\n\r\n  panic() {\r\n    this.element.classList.remove(\"collapse\");\r\n    this.element.ariaHidden = \"false\";\r\n    this.contents.textContent =\r\n      `Something went wrong while trying to ${this.action}. Try again later.`;\r\n  }\r\n}\r\n\r\nexport class Input {\r\n  input: HTMLInputElement;\r\n  error: HTMLElement;\r\n\r\n  constructor(formId: string, inputId: string) {\r\n    this.input = getElementById<HTMLInputElement>(`${formId}${inputId}/input`, HTMLInputElement);\r\n    this.error = getElementById<HTMLElement>(`${formId}${inputId}/error`, HTMLElement);\r\n\r\n    this.input.addEventListener(\"input\", () => {\r\n      this.input.setCustomValidity(\"\");\r\n    });\r\n  }\r\n\r\n  getValue(): string {\r\n    if (this.input.type === \"checkbox\") {\r\n      if (this.input.checked) {\r\n        return \"checked\";\r\n      } else {\r\n        return \"unchecked\";\r\n      }\r\n    } else {\r\n      return this.input.value;\r\n    }\r\n  }\r\n\r\n  setLock(lock: boolean) {\r\n    this.input.disabled = lock;\r\n  }\r\n\r\n  clearError() {\r\n    this.input.setCustomValidity(\"\");\r\n    this.error.classList.add(\"hidden\");\r\n    this.error.ariaHidden = \"true\";\r\n    this.error.textContent = \"!\";\r\n  }\r\n\r\n  addError(error: string) {\r\n    if (this.error.textContent === \"!\") {\r\n      this.input.setCustomValidity(error);\r\n      this.error.classList.remove(\"hidden\");\r\n      this.error.ariaHidden = \"false\";\r\n      this.error.textContent = `Invalid value: ${error}`;\r\n      return;\r\n    }\r\n    this.error.textContent += `, ${error}`;\r\n    this.input.setCustomValidity(this.error.textContent ?? \"Invalid value\");\r\n  }\r\n}\r\n\r\nexport class Form {\r\n  form: HTMLFormElement;\r\n  formError: FormError;\r\n  submitButton: HTMLButtonElement;\r\n  inputs: Map<string, Input>;\r\n\r\n  constructor(formId: string, inputIds: string[], action: string) {\r\n    this.form = getElementById<HTMLFormElement>(formId, HTMLFormElement);\r\n    this.formError = new FormError(formId, action);\r\n    this.submitButton = getElementById<HTMLButtonElement>(`${formId}/submit`, HTMLButtonElement);\r\n\r\n    const inputs = new Map<string, Input>();\r\n    for (const inputId of inputIds) {\r\n      inputs.set(inputId, new Input(formId, inputId));\r\n    }\r\n    this.inputs = inputs;\r\n  }\r\n\r\n  clearErrors() {\r\n    this.formError.clearError();\r\n    for (const input of this.inputs.values()) {\r\n      input.clearError();\r\n    }\r\n  }\r\n\r\n  setLock(lock: boolean) {\r\n    this.submitButton.disabled = lock;\r\n    for (const input of this.inputs.values()) {\r\n      input.setLock(lock);\r\n    }\r\n  }\r\n\r\n  setInputErrors(problems: Problem[] | null) {\r\n    if (!problems || problems.length === 0) {\r\n      this.formError.addError(\"an unknown field is invalid\");\r\n      return;\r\n    }\r\n\r\n    for (const problem of problems) {\r\n      const input = this.inputs.get(problem.pointer) ?? null;\r\n\r\n      if (input) {\r\n        input.addError(problem.detail);\r\n      } else {\r\n        this.formError.addError(`field ${problem.pointer} ${problem.detail}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  getValues(): Map<string, string> {\r\n    const map = new Map();\r\n    for (const [id, input] of this.inputs) {\r\n      map.set(id, input.getValue());\r\n    }\r\n    return map;\r\n  }\r\n}\r\n\r\n// deno-lint-ignore no-explicit-any\r\ntype Class<T> = new (...args: any[]) => T;\r\n\r\n/**\r\n * # Panics\r\n * If element does not exist or is not an instance of the expected type.\r\n */\r\nfunction getElementById<T extends HTMLElement>(id: string, expected: Class<T>): T {\r\n  const element = document.getElementById(id);\r\n  if (!element || !(element instanceof expected)) {\r\n    throw `element '${id}' does not exist`;\r\n  }\r\n  return element;\r\n}\r\n", "export async function setHref(target: string): Promise<never> {\r\n  location.href = target;\r\n  return await block();\r\n}\r\n\r\nfunction block(): Promise<never> {\r\n  // deno-lint-ignore no-explicit-any\r\n  const poll = (resolve: any) => {\r\n    setTimeout(() => poll(resolve), 400);\r\n  };\r\n\r\n  return new Promise(poll);\r\n}\r\n", "declare global {\r\n  interface Uint8Array<TArrayBuffer extends ArrayBufferLike> {\r\n    toBase64(options?: { alphabet?: \"base64\" | \"base64url\"; omitPadding?: boolean }): string;\r\n  }\r\n\r\n  interface Uint8ArrayConstructor {\r\n    fromBase64(\r\n      string: string,\r\n      options?: {\r\n        alphabet?: \"base64\" | \"base64url\";\r\n        lastChunkHandling?: \"loose\" | \"strict\" | \"stop-before-partial\";\r\n      },\r\n    ): Uint8Array;\r\n  }\r\n}\r\n\r\nexport function base64Decode(input: string): Uint8Array {\r\n  return Uint8Array.fromBase64(input, {\r\n    alphabet: \"base64url\",\r\n    lastChunkHandling: \"loose\",\r\n  });\r\n}\r\n\r\nexport function base64Encode(input: Uint8Array): string {\r\n  return input.toBase64({ alphabet: \"base64url\", omitPadding: true });\r\n}\r\n", "export type Problem = {\r\n  pointer: string;\r\n  detail: string;\r\n};\r\n\r\nexport type ServerResponse<T> =\r\n  | { status: \"ok\"; body: T }\r\n  | { status: \"badRequest\"; problems: Problem[] }\r\n  | { status: \"unauthenticated\" }\r\n  | { status: \"error\" }\r\n  | never;\r\n\r\nexport type Header = [string, string];\r\n\r\nexport const TOKEN_KEY = \"token\";\r\n\r\nexport class FetchBuilder {\r\n  #method: \"GET\" | \"POST\" | \"PUT\" | \"DELETE\";\r\n  #url: string;\r\n  #additionalHeaders: Header[] | null = null;\r\n  #body: object | null = null;\r\n\r\n  constructor(method: \"GET\" | \"POST\" | \"PUT\" | \"DELETE\", url: string) {\r\n    this.#method = method;\r\n    this.#url = url;\r\n  }\r\n\r\n  setBody(body: object | null): FetchBuilder {\r\n    this.#body = body;\r\n    return this;\r\n  }\r\n\r\n  setHeaders(headers: Header[] | null): FetchBuilder {\r\n    this.#additionalHeaders = headers;\r\n    return this;\r\n  }\r\n\r\n  async fetch<T>(): Promise<ServerResponse<T>> {\r\n    return await fetch(\r\n      this.#method,\r\n      this.#url,\r\n      this.#additionalHeaders,\r\n      this.#body,\r\n    );\r\n  }\r\n}\r\n\r\nexport async function fetch<T>(\r\n  method: \"GET\" | \"POST\" | \"PUT\" | \"DELETE\",\r\n  url: string,\r\n  additionalHeaders: Header[] | null,\r\n  body: object | null,\r\n): Promise<ServerResponse<T>> {\r\n  const headers = new Headers();\r\n\r\n  if (additionalHeaders) {\r\n    for (const header of additionalHeaders) {\r\n      headers.append(header[0], header[1]);\r\n    }\r\n  }\r\n\r\n  if (body) {\r\n    headers.append(\"content-type\", \"application/json\");\r\n  }\r\n\r\n  const token = localStorage.getItem(TOKEN_KEY);\r\n  if (token && !headers.has(\"Authorization\")) {\r\n    headers.append(\"Authorization\", token);\r\n  }\r\n\r\n  let bodyContent = null;\r\n  if (body) {\r\n    bodyContent = JSON.stringify(body);\r\n  }\r\n\r\n  const response = await self.fetch(url, {\r\n    method,\r\n    body: bodyContent,\r\n    headers,\r\n  }).catch((ex) => {\r\n    console.warn(ex);\r\n    return new Response(null, { status: 500 });\r\n  });\r\n\r\n  if (response.ok) {\r\n    const bearer = response.headers.get(\"Authorization\");\r\n    if (bearer) {\r\n      localStorage.setItem(TOKEN_KEY, bearer);\r\n    }\r\n\r\n    const body = await response.json().catch((ex) => {\r\n      console.warn(ex);\r\n      return {};\r\n    });\r\n\r\n    return {\r\n      status: \"ok\",\r\n      body,\r\n    };\r\n  }\r\n\r\n  switch (response.status) {\r\n    case 400: {\r\n      const body = await response.json().catch((ex) => {\r\n        console.warn(ex);\r\n        return { problems: [] };\r\n      });\r\n\r\n      return {\r\n        status: \"badRequest\",\r\n        problems: body.problems ?? [],\r\n      };\r\n    }\r\n    case 401:\r\n    case 403: {\r\n      return { status: \"unauthenticated\" };\r\n    }\r\n  }\r\n\r\n  return { status: \"error\" };\r\n}\r\n", "import { Header } from \"../lib/fetch.ts\";\r\n\r\nexport const API_URL = \"http://localhost:8081\";\r\nexport const API_KEY: Header = [\"X-TS-API-Key\", \"identity-site\"];\r\n", "import { base64Decode } from \"../lib/base64.ts\";\r\nimport { FetchBuilder, TOKEN_KEY } from \"../lib/fetch.ts\";\r\nimport { setHref } from \"../lib/redirect.ts\";\r\nimport { TokenDetails } from \"../types.ts\";\r\nimport { API_KEY, API_URL } from \"./config.ts\";\r\n\r\nexport function getToken(): TokenDetails | null {\r\n  const token = localStorage.getItem(TOKEN_KEY);\r\n  if (!token) {\r\n    return null;\r\n  }\r\n\r\n  const parts = token.split(\".\");\r\n  if (parts.length !== 3) {\r\n    localStorage.removeItem(TOKEN_KEY);\r\n    return null;\r\n  }\r\n\r\n  const decoder = new TextDecoder();\r\n  const claims = JSON.parse(decoder.decode(base64Decode(parts[1])));\r\n\r\n  return {\r\n    bearer: token,\r\n    act: claims.act ?? null,\r\n    exp: claims.exp,\r\n    sub: claims.sub,\r\n    typ: claims.typ,\r\n    tid: claims.tid,\r\n  };\r\n}\r\n\r\nexport async function logout(should_return: boolean): Promise<never> {\r\n  const token = localStorage.getItem(TOKEN_KEY);\r\n  if (token) {\r\n    await new FetchBuilder(\"POST\", API_URL + \"/revoked-tokens\").setHeaders([API_KEY]).fetch();\r\n    alert(\"Your session has expired\");\r\n  }\r\n  localStorage.removeItem(TOKEN_KEY);\r\n\r\n  const href = should_return ? `/login?redirect=${encodeURI(location.href)}` : \"/login\";\r\n  return await setHref(href);\r\n}\r\n", "import { base64Encode } from \"../lib/base64.ts\";\r\nimport { FetchBuilder, TOKEN_KEY } from \"../lib/fetch.ts\";\r\nimport { Challenge, Identity, TokenDetails } from \"../types.ts\";\r\nimport { API_KEY, API_URL } from \"./config.ts\";\r\n\r\ntype WebAuthNResult<T> =\r\n  | { status: \"ok\"; data: T }\r\n  | { status: \"cancelled\" }\r\n  | { status: \"unauthenticated\" }\r\n  | { status: \"error\" };\r\n\r\nexport async function requestPasskeyCreation(\r\n  token: TokenDetails,\r\n  preferResidentKey: boolean,\r\n  displayName: string,\r\n): Promise<WebAuthNResult<object>> {\r\n  const challenge = await getChallenge(token.sub);\r\n  if (challenge.status !== \"ok\") {\r\n    return challenge;\r\n  }\r\n\r\n  const relyingParty = await getRelyingParty();\r\n  if (relyingParty.status !== \"ok\") {\r\n    return relyingParty;\r\n  }\r\n\r\n  const existingCredentials = await getExistingCredentials(token.sub, null);\r\n  if (existingCredentials.status !== \"ok\") {\r\n    return existingCredentials;\r\n  }\r\n\r\n  const identity = await getIdentity(token);\r\n  if (identity.status !== \"ok\") {\r\n    return identity;\r\n  }\r\n\r\n  const publicKeyParameters = await getPublicKeyParameters();\r\n  if (publicKeyParameters.status !== \"ok\") {\r\n    return publicKeyParameters;\r\n  }\r\n\r\n  const jsonOptions: PublicKeyCredentialCreationOptionsJSON = {\r\n    challenge: challenge.data,\r\n    excludeCredentials: existingCredentials.data,\r\n    hints: [\"security-key\", \"hybrid\", \"client-device\"],\r\n    rp: relyingParty.data,\r\n    pubKeyCredParams: publicKeyParameters.data,\r\n    user: {\r\n      displayName: identity.data.displayName,\r\n      id: identity.data.id,\r\n      name: identity.data.username,\r\n    },\r\n    authenticatorSelection: {\r\n      residentKey: preferResidentKey ? \"preferred\" : \"discouraged\",\r\n      userVerification: \"preferred\",\r\n    },\r\n  };\r\n\r\n  const options = PublicKeyCredential.parseCreationOptionsFromJSON(jsonOptions);\r\n  const credential = await navigator.credentials.create({ publicKey: options }).catch(() => {\r\n    return null;\r\n  });\r\n  if (!credential) {\r\n    return { status: \"cancelled\" };\r\n  }\r\n  if (!(credential instanceof PublicKeyCredential)) {\r\n    return { status: \"error\" };\r\n  }\r\n\r\n  return await requestCredentialCreation(credential, displayName);\r\n}\r\n\r\nexport async function requestCommonToken(\r\n  username: string | null,\r\n): Promise<WebAuthNResult<string>> {\r\n  const challenge = await getChallenge(null);\r\n  if (challenge.status !== \"ok\") {\r\n    return challenge;\r\n  }\r\n\r\n  const relyingParty = await getRelyingParty();\r\n  if (relyingParty.status !== \"ok\") {\r\n    return relyingParty;\r\n  }\r\n\r\n  const existingCredentials = await getExistingCredentials(null, username);\r\n  if (existingCredentials.status !== \"ok\") {\r\n    return existingCredentials;\r\n  }\r\n\r\n  const jsonOptions: PublicKeyCredentialRequestOptionsJSON = {\r\n    challenge: challenge.data,\r\n    allowCredentials: existingCredentials.data,\r\n    hints: [\"security-key\", \"hybrid\", \"client-device\"],\r\n    rpId: relyingParty.data.id,\r\n    userVerification: \"required\",\r\n  };\r\n\r\n  const options = PublicKeyCredential.parseRequestOptionsFromJSON(jsonOptions);\r\n  const credential = await navigator.credentials.get({ publicKey: options }).catch(() => {\r\n    return null;\r\n  });\r\n  if (!credential) {\r\n    return { status: \"cancelled\" };\r\n  }\r\n  if (!(credential instanceof PublicKeyCredential)) {\r\n    return { status: \"error\" };\r\n  }\r\n\r\n  return await requestTokenIssued(credential, \"common\", null);\r\n}\r\nexport async function requestConsentToken(\r\n  originalToken: TokenDetails,\r\n  action: string,\r\n): Promise<WebAuthNResult<string>> {\r\n  const challenge = await getChallenge(originalToken.sub);\r\n  if (challenge.status !== \"ok\") {\r\n    return challenge;\r\n  }\r\n\r\n  const relyingParty = await getRelyingParty();\r\n  if (relyingParty.status !== \"ok\") {\r\n    return relyingParty;\r\n  }\r\n\r\n  const existingCredentials = await getExistingCredentials(originalToken.sub, null);\r\n  if (existingCredentials.status !== \"ok\") {\r\n    return existingCredentials;\r\n  }\r\n\r\n  const jsonOptions: PublicKeyCredentialRequestOptionsJSON = {\r\n    challenge: challenge.data,\r\n    allowCredentials: existingCredentials.data,\r\n    hints: [\"security-key\", \"hybrid\", \"client-device\"],\r\n    rpId: relyingParty.data.id,\r\n    userVerification: \"required\",\r\n  };\r\n\r\n  const options = PublicKeyCredential.parseRequestOptionsFromJSON(jsonOptions);\r\n  const credential = await navigator.credentials.get({ publicKey: options }).catch(() => {\r\n    return null;\r\n  });\r\n  if (!credential) {\r\n    return { status: \"cancelled\" };\r\n  }\r\n  if (!(credential instanceof PublicKeyCredential)) {\r\n    return { status: \"error\" };\r\n  }\r\n\r\n  const token = await requestTokenIssued(credential, \"consent\", action);\r\n  localStorage.setItem(TOKEN_KEY, originalToken.bearer);\r\n  return token;\r\n}\r\n\r\nasync function getRelyingParty(): Promise<WebAuthNResult<PublicKeyCredentialRpEntity>> {\r\n  const response = await new FetchBuilder(\"GET\", API_URL + \"/.well-known/relying-party.json\")\r\n    .setHeaders([API_KEY])\r\n    .fetch<PublicKeyCredentialRpEntity>();\r\n  if (response.status === \"ok\") {\r\n    return { status: \"ok\", data: response.body };\r\n  }\r\n  else if (response.status === \"unauthenticated\") {\r\n    return { status: \"unauthenticated\" };\r\n  }\r\n  else {\r\n    return { status: \"error\" };\r\n  }\r\n}\r\n\r\nasync function getExistingCredentials(\r\n  identityId: string | null,\r\n  username: string | null,\r\n): Promise<WebAuthNResult<PublicKeyCredentialDescriptorJSON[]>> {\r\n  let query = \"\";\r\n  if (identityId) {\r\n    query = `?identityId=${identityId}`;\r\n  }\r\n  else if (username) {\r\n    query = `?username=${username}`;\r\n  }\r\n  const response = await new FetchBuilder(\"GET\", API_URL + `/existing-credentials${query}`)\r\n    .setHeaders([API_KEY])\r\n    .fetch<{ credentials: PublicKeyCredentialDescriptorJSON[] }>();\r\n  if (response.status === \"ok\") {\r\n    return { status: \"ok\", data: response.body.credentials };\r\n  }\r\n  else if (response.status === \"unauthenticated\") {\r\n    return { status: \"unauthenticated\" };\r\n  }\r\n  else {\r\n    return { status: \"error\" };\r\n  }\r\n}\r\n\r\nasync function getChallenge(\r\n  identityId: string | null,\r\n): Promise<WebAuthNResult<string>> {\r\n  const response = await new FetchBuilder(\"POST\", API_URL + \"/challenges\")\r\n    .setBody({ identityId: identityId })\r\n    .setHeaders([API_KEY])\r\n    .fetch<Challenge>();\r\n  if (response.status === \"ok\") {\r\n    return { status: \"ok\", data: response.body.challenge };\r\n  }\r\n  else if (response.status === \"unauthenticated\") {\r\n    return { status: \"unauthenticated\" };\r\n  }\r\n  else {\r\n    return { status: \"error\" };\r\n  }\r\n}\r\n\r\nasync function requestTokenIssued(\r\n  credential: PublicKeyCredential,\r\n  type: \"consent\" | \"common\",\r\n  action: string | null,\r\n): Promise<WebAuthNResult<string>> {\r\n  if (!(credential.response instanceof AuthenticatorAssertionResponse)) {\r\n    return { status: \"error\" };\r\n  }\r\n  const response = await new FetchBuilder(\"POST\", API_URL + \"/tokens\")\r\n    .setHeaders([API_KEY])\r\n    .setBody({\r\n      credential: {\r\n        id: credential.id,\r\n        authenticatorAttachment: credential.authenticatorAttachment,\r\n        rawId: base64Encode(new Uint8Array(credential.rawId)),\r\n        response: {\r\n          authenticatorData: base64Encode(new Uint8Array(credential.response.authenticatorData)),\r\n          clientDataJSON: base64Encode(new Uint8Array(credential.response.clientDataJSON)),\r\n          signature: base64Encode(new Uint8Array(credential.response.signature)),\r\n          userHandle: credential.response.userHandle\r\n            ? base64Encode(new Uint8Array(credential.response.userHandle))\r\n            : null,\r\n        },\r\n      },\r\n      typ: type,\r\n      act: action,\r\n    })\r\n    .fetch<TokenDetails>();\r\n  if (response.status === \"unauthenticated\") {\r\n    return { status: \"unauthenticated\" };\r\n  }\r\n  else if (response.status !== \"ok\") {\r\n    return { status: \"error\" };\r\n  }\r\n\r\n  const token = localStorage.getItem(TOKEN_KEY);\r\n  if (!token) {\r\n    return { status: \"error\" };\r\n  }\r\n  return { status: \"ok\", data: token };\r\n}\r\n\r\nasync function requestCredentialCreation(\r\n  credential: PublicKeyCredential,\r\n  displayName: string,\r\n): Promise<WebAuthNResult<object>> {\r\n  if (!(credential.response instanceof AuthenticatorAttestationResponse)) {\r\n    return { status: \"error\" };\r\n  }\r\n\r\n  const publicKey = credential.response.getPublicKey();\r\n  if (!publicKey) {\r\n    return { status: \"error\" };\r\n  }\r\n\r\n  const response = await new FetchBuilder(\"POST\", API_URL + \"/public-keys\")\r\n    .setHeaders([API_KEY])\r\n    .setBody({\r\n      displayName,\r\n      credential: {\r\n        authenticatorAttachment: credential.authenticatorAttachment,\r\n        id: credential.id,\r\n        rawId: base64Encode(new Uint8Array(credential.rawId)),\r\n        response: {\r\n          attestationObject: base64Encode(new Uint8Array(credential.response.attestationObject)),\r\n          clientDataJSON: base64Encode(new Uint8Array(credential.response.clientDataJSON)),\r\n          authenticatorData: base64Encode(\r\n            new Uint8Array(credential.response.getAuthenticatorData()),\r\n          ),\r\n          publicKey: base64Encode(new Uint8Array(publicKey)),\r\n          publicKeyAlgorithm: credential.response.getPublicKeyAlgorithm(),\r\n          transports: credential.response.getTransports(),\r\n        },\r\n      },\r\n    })\r\n    .fetch();\r\n\r\n  if (response.status === \"ok\") {\r\n    return { status: \"ok\", data: {} };\r\n  }\r\n  else if (response.status === \"unauthenticated\") {\r\n    return { status: \"unauthenticated\" };\r\n  }\r\n  else {\r\n    return { status: \"error\" };\r\n  }\r\n}\r\n\r\nexport async function getIdentity(\r\n  token: TokenDetails,\r\n): Promise<WebAuthNResult<Identity>> {\r\n  const response = await new FetchBuilder(\"GET\", API_URL + `/identities/${token.sub}`)\r\n    .setHeaders([API_KEY])\r\n    .fetch<Identity>();\r\n  if (response.status === \"ok\") {\r\n    return { status: \"ok\", data: response.body };\r\n  }\r\n  else if (response.status === \"unauthenticated\") {\r\n    return { status: \"unauthenticated\" };\r\n  }\r\n  else {\r\n    return { status: \"error\" };\r\n  }\r\n}\r\n\r\nasync function getPublicKeyParameters(): Promise<WebAuthNResult<PublicKeyCredentialParameters[]>> {\r\n  const response = await new FetchBuilder(\r\n    \"GET\",\r\n    API_URL + `/.well-known/public-key-parameters.json`,\r\n  )\r\n    .setHeaders([API_KEY])\r\n    .fetch<{ publicKeyParameters: PublicKeyCredentialParameters[] }>();\r\n  if (response.status === \"ok\") {\r\n    return { status: \"ok\", data: response.body.publicKeyParameters };\r\n  }\r\n  else if (response.status === \"unauthenticated\") {\r\n    return { status: \"unauthenticated\" };\r\n  }\r\n  else {\r\n    return { status: \"error\" };\r\n  }\r\n}\r\n", "import { Form } from \"../lib/form.ts\";\r\nimport { setHref } from \"../lib/redirect.ts\";\r\nimport { getToken, logout } from \"../scripts/token.ts\";\r\nimport { requestPasskeyCreation } from \"../scripts/webauthn.ts\";\r\n\r\nconst token = getToken();\r\nif (!token) {\r\n  await setHref(\"/login\");\r\n  throw new Error();\r\n}\r\n\r\ndocument.getElementById(\"cancel\")?.addEventListener(\"mouseup\", async (event) => {\r\n  event.preventDefault();\r\n\r\n  if (token.typ === \"provisioning\") {\r\n    await logout(false);\r\n  }\r\n  else {\r\n    await setHref(\"/identity\");\r\n  }\r\n});\r\n\r\nconst form = new Form(\"/addPasskey\", [\"/displayName\", \"/residentKey\"], \"register a passkey\");\r\nform.form.addEventListener(\"submit\", async (event) => {\r\n  event.preventDefault();\r\n\r\n  try {\r\n    form.setLock(true);\r\n    form.clearErrors();\r\n\r\n    const values = form.getValues();\r\n    const displayName = values.get(\"/displayName\") ?? \"\";\r\n    const preferResidentKey = values.get(\"/residentKey\") ?? \"unchecked\";\r\n\r\n    const currentToken = getToken();\r\n    if (!currentToken) {\r\n      await setHref(\"/login\");\r\n      throw new Error();\r\n    }\r\n\r\n    const result = await requestPasskeyCreation(\r\n      currentToken,\r\n      preferResidentKey === \"checked\",\r\n      displayName,\r\n    );\r\n    if (result.status === \"ok\") {\r\n      const params = new URLSearchParams(document.location.search);\r\n      const redirect = params.get(\"redirect\");\r\n      const nextPage = redirect ? decodeURI(redirect) : \"/identity\";\r\n      await setHref(nextPage);\r\n    }\r\n    else if (result.status === \"cancelled\") {\r\n      form.formError.addError(\"the prompt was cancelled\");\r\n      form.setLock(false);\r\n      return;\r\n    }\r\n    else if (result.status === \"unauthenticated\") {\r\n      await logout(false);\r\n    }\r\n    else {\r\n      form.formError.panic();\r\n      form.setLock(false);\r\n      return;\r\n    }\r\n  }\r\n  finally {\r\n    form.setLock(false);\r\n  }\r\n});\r\n"],
  "mappings": "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",
  "names": ["FormError", "formId", "action", "getElementById", "error", "Input", "inputId", "lock", "Form", "inputIds", "inputs", "input", "problems", "problem", "map", "id", "expected", "element", "setHref", "target", "block", "poll", "resolve", "base64Decode", "input", "base64Encode", "TOKEN_KEY", "FetchBuilder", "#method", "#url", "#additionalHeaders", "#body", "method", "url", "body", "headers", "fetch", "additionalHeaders", "header", "token", "bodyContent", "response", "ex", "bearer", "API_URL", "API_KEY", "getToken", "token", "TOKEN_KEY", "parts", "decoder", "claims", "base64Decode", "logout", "should_return", "FetchBuilder", "API_URL", "API_KEY", "href", "setHref", "requestPasskeyCreation", "token", "preferResidentKey", "displayName", "challenge", "getChallenge", "relyingParty", "getRelyingParty", "existingCredentials", "getExistingCredentials", "identity", "getIdentity", "publicKeyParameters", "getPublicKeyParameters", "jsonOptions", "options", "credential", "requestCredentialCreation", "getRelyingParty", "response", "FetchBuilder", "API_URL", "API_KEY", "getExistingCredentials", "identityId", "username", "query", "getChallenge", "requestCredentialCreation", "credential", "displayName", "publicKey", "response", "FetchBuilder", "API_URL", "API_KEY", "base64Encode", "getIdentity", "token", "getPublicKeyParameters", "token", "getToken", "setHref", "event", "logout", "form", "Form", "values", "displayName", "preferResidentKey", "currentToken", "result", "requestPasskeyCreation", "redirect", "nextPage"]
}
